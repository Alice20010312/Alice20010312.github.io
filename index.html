<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 5.4.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-最短路径“" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/08/08/%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E2%80%9C/" class="article-date">
  <time class="dt-published" datetime="2021-08-08T11:11:56.000Z" itemprop="datePublished">2021-08-08</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/08/08/%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E2%80%9C/">最短路径“</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p><strong>一共介绍了四种算法</strong></p>
<p><strong>只有五行的算法</strong><br><strong>单源最短路</strong><br><strong>解决负权边</strong><br><strong>负边权-优化处理</strong><br><strong>Floyd-Warshall-只有五行的算法</strong></p>
<pre><code>   算法思想：在不允许经过额外点的情况下，两点的最短路径就是两点间的路径长度。然后加入中间的点之后发生变化。
</code></pre>
<p>Floyd-Warshall算法<br>通常可以在任何图中使用，包括有向图、带负权边的图，但是不能解决带有“负权回路”（负权环）的图。</p>
<p>Floyd-Warshall 算法用来找出每对点之间的最短距离。</p>
<p>感觉啊哈算法讲的就是详细简单，非常容易理解。<br>城市+公路（单向道路）</p>
<p>现在需要求任意两个城市之间的最短路程，即两点间的最短路径——“多源最短路径”问题。<br>仍然用原来的方法，用矩阵存储图，初始化无穷，自己到自己的路程为0。上面写了深度优先搜索和广度优先搜索的方法，时间复杂度是O(n^2)，Floyd-Warshall算法是计算每一对顶点间的最短路径，所以时间复杂度是O(n^3).</p>
<p>算法描述：求u和v两点之间的距离，路程的表示可以用直接两点间的边，也可以用中间加入点k1的方法，那么路程就是u到k1的边加上k1到v，然后比较一下取最小值就得到目前状态的最短路径了，然后你还可以通过中间的k1，k2……kn点中转（感觉中转这个词用的特比贴切），每次都取最小值。<br>例如：求任意两点u和v之间的最短距离时，每次都允许它从1城市中转，那么用数组存储就是e[u][v],中转后的路程就是e[u][1]+e[1][v]，两者比较求最小值，再用e[u][v]存储，就是目前状态的最短路径了。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"> </span><br><span class="line">const int INF = 99999999;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int e[10][10],dis[10],book[10];</span><br><span class="line">    int n,m;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line"> </span><br><span class="line">    for(int i=1;i&lt;=n;i++)</span><br><span class="line">        for(int j=1;j&lt;=n;j++)</span><br><span class="line">            if(i==j)    e[i][j]=0;</span><br><span class="line">                else    e[i][j]=INF;</span><br><span class="line">    int t1,t2,t3;</span><br><span class="line">    for(int i=1;i&lt;=m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        scanf(&quot;%d%d%d&quot;,&amp;t1,&amp;t2,&amp;t3);</span><br><span class="line">        e[t1][t2]=t3;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    //初始化dis数组，哲理是1号顶点到其余各顶点的初始路程</span><br><span class="line">    for(int i=1;i&lt;=n;i++)</span><br><span class="line">        dis[i]=e[1][i];</span><br><span class="line"> </span><br><span class="line">    memset(book,0,sizeof(book));//初始化</span><br><span class="line">    book[1]=1;//因为1点是源点</span><br><span class="line"> </span><br><span class="line">    int minn,u,v;</span><br><span class="line">    //Dijkstra算法核心语句</span><br><span class="line">    for(int i=1;i&lt;=n-1;i++)//n-1</span><br><span class="line">    &#123;</span><br><span class="line">        //找到离1号顶点最近的顶点</span><br><span class="line">        //是每次都要找</span><br><span class="line">        minn=INF;</span><br><span class="line">        for(int j=1;j&lt;=n;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            if(book[j]==0&amp;&amp;dis[j]&lt;minn)</span><br><span class="line">            &#123;</span><br><span class="line">                minn=dis[j];</span><br><span class="line">                u=j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        book[u]=1;//一个新的起点</span><br><span class="line">        for(v=1;v&lt;=n;v++)</span><br><span class="line">        &#123;</span><br><span class="line">            if(e[u][v]&lt;INF)</span><br><span class="line">            &#123;</span><br><span class="line">                if(dis[v]&gt;dis[u]+e[u][v])</span><br><span class="line">                    dis[v]=dis[u]+e[u][v];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    //输出</span><br><span class="line">    for(int i=1;i&lt;=n;i++)</span><br><span class="line">        printf(&quot;%d\n&quot;,dis[i]);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">/*</span><br><span class="line">6 9</span><br><span class="line">1 2 1</span><br><span class="line">1 3 12</span><br><span class="line">2 3 9</span><br><span class="line">2 4 3</span><br><span class="line">3 5 5</span><br><span class="line">4 3 4</span><br><span class="line">4 5 13</span><br><span class="line">4 6 15</span><br><span class="line">5 6 4</span><br><span class="line">*/</span><br></pre></td></tr></table></figure>

<p>Bellman-Ford算法——解决负权边<br>Bellman-Ford算法是求含负权图的单源最短路径算法，算法核心是多轮对所有的边进行松弛。<br>  第一轮在对所有的边进行松弛后，得到的是从1号顶点每次“途径一个边”到达所以顶点的最短路径，要理解这个“途径一个边”的含义，意即：经过一条边，如果可达的顶点，则为其当前状态最短路径；不可达的话，就依然保持其原来的状态∞。<br>  然后接下来进行的第k轮松弛，得到的就是从1号顶点每次“途径k条边”达到所以顶点的最短路径。<br>  那么要进行多少轮松弛，才能真正的得到顶点1到所有顶点的最短路径呢？<br>  理论上来说，要经过n-1轮，即进行完“‘途径n-1条边’达到所有顶点的最短路径”这个状态，这时候已经可以结束了，因为n顶点图中，任意两点间的路径至多是n-1条边（此处不考虑含负权回路的情况）。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int dis[10],n,m,u[10],v[10],w[10];</span><br><span class="line">    const int INF = 99999999;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line"> </span><br><span class="line">    for(int i=1;i&lt;=m;i++)</span><br><span class="line">        scanf(&quot;%d%d%d&quot;,&amp;u[i],&amp;v[i],&amp;w[i]);</span><br><span class="line"> </span><br><span class="line">    //初始化dis数组，这里的是1号2顶点到其余各顶点的出事路程</span><br><span class="line">    for(int i=1;i&lt;=n;i++)</span><br><span class="line">        dis[i]=INF;</span><br><span class="line">    dis[1]=0;</span><br><span class="line"> </span><br><span class="line">    //Bellman-Ford算法核心语句</span><br><span class="line">    for(int k=1;k&lt;=n-1;k++)//       进行n-1轮松弛</span><br><span class="line">        for(int i=1;i&lt;=m;i++)//     枚举每一条边</span><br><span class="line">            if(dis[v[i]] &gt; dis[u[i]] + w[i])//      尝试对每一条边进行松弛</span><br><span class="line">                dis[v[i]] = dis[u[i]] + w[i];</span><br><span class="line"> </span><br><span class="line">    for(int i=1;i&lt;=n;i++)</span><br><span class="line">        printf(&quot;%d\n&quot;,dis[i]);</span><br><span class="line">&#125;</span><br><span class="line">/*</span><br><span class="line">5 5 </span><br><span class="line">2 3 2</span><br><span class="line">1 2 -3</span><br><span class="line">1 5 5</span><br><span class="line">4 5 2</span><br><span class="line">3 4 3</span><br><span class="line">*/</span><br></pre></td></tr></table></figure>

<p>检测负权回路：</p>
<p>用标记变量进行优化：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> dis[<span class="number">10</span>],n,m,u[<span class="number">10</span>],v[<span class="number">10</span>],w[<span class="number">10</span>],check;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">99999999</span>;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;u[i],&amp;v[i],&amp;w[i]);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//初始化dis数组，这里的是1号2顶点到其余各顶点的出事路程</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        dis[i]=INF;</span><br><span class="line">    dis[<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//Bellman-Ford算法核心语句</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">1</span>;k&lt;=n<span class="number">-1</span>;k++)<span class="comment">//       进行n-1轮松弛</span></span><br><span class="line">    &#123;</span><br><span class="line">        check=<span class="number">0</span>;<span class="comment">//标记这一轮是否进行更新</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)<span class="comment">//     枚举每一条边</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(dis[v[i]] &gt; dis[u[i]] + w[i])<span class="comment">//      尝试对每一条边进行松弛</span></span><br><span class="line">            &#123;</span><br><span class="line">                dis[v[i]] = dis[u[i]] + w[i];</span><br><span class="line">                check=<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(check==<span class="number">0</span>)<span class="comment">//确定dis数组不再进行更新了，就提前退出循环</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    <span class="comment">//检测负权回路</span></span><br><span class="line">    <span class="keyword">int</span> flag=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">        <span class="keyword">if</span>(dis[v[i]] &gt; dis[u[i]] + w[i])</span><br><span class="line">            flag=<span class="number">1</span>;<span class="comment">//还可以继续松弛的话</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span>(flag)</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;此图含有负权回路&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,dis[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">5 5</span></span><br><span class="line"><span class="comment">2 3 2</span></span><br><span class="line"><span class="comment">1 2 -3</span></span><br><span class="line"><span class="comment">1 5 5</span></span><br><span class="line"><span class="comment">4 5 2</span></span><br><span class="line"><span class="comment">3 4 3</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/08/08/%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E2%80%9C/" data-id="cks347apg000480uw4st25swh" data-title="最短路径“" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-图的遍历" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/08/05/%E5%9B%BE%E7%9A%84%E9%81%8D%E5%8E%86/" class="article-date">
  <time class="dt-published" datetime="2021-08-05T13:00:35.000Z" itemprop="datePublished">2021-08-05</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/08/05/%E5%9B%BE%E7%9A%84%E9%81%8D%E5%8E%86/">图的遍历</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>文章目录**<br><strong>定义</strong><br>深度优先遍历<br>广度优先遍历<br>测试代码<br><strong>定义</strong><br><strong>从图中某一顶点出发访遍图中其余顶点，且使每一个顶点仅被访问一次，这一过程就叫做图的遍历（Traversing Graph）。</strong></p>
<p><strong>深度优先遍历</strong><br><strong>深度优先遍历（Depth_First_Search）,也有称深度优先搜索，简称DFS</strong>。</p>
<p>为了理解深度优先遍历，用一个小游戏来说明。<br>假设你要完成一个任务，要求在如图1-1中的左图中这样的一个迷宫中，从顶点A开始要走遍所有的图顶点并做上标记，注意不是简单地看着这样的平面图走哦。而是如同现实般地只有高墙和通道的迷宫中去完成任务</p>
<p><img src="https://img-blog.csdnimg.cn/20200716101601742.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3hpYW5nanVueWVz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>​                                                                                           图1-1<br>很显然是需要策略的，现在使用深度优先遍历来完成。</p>
<p>首先从顶点A开始，做上表示做过的记号之后，前面有两条路，通向B和F，我们给自己一个原则，在没有碰到重复顶点的情况下，始终是向右手边走，于是走到了顶点B，整个行走过程，可参看图1-1的右图。此时发现有三个分支，分别通往顶点C,I,G右手通行原则，我们走到了顶点C，就这样，我们一直顺着右手通道走，一直走到顶点F，当我们依然选择右手通道走过去时，发现走回到顶点A了。此时我们退回到顶点F，走向从右数的第二条通道，到了G点，他有三条通道，B和D是已经走过的，于是走到H，当我们走到H时，发现两条通道D和E，会发现都已经走过了。</p>
<p>此时我们没有遍历完所有的顶点，在顶点H处，在无通道没走过，返回到G，也无从未走过的通道，回到F，没有通道。回到E，有一条通向H的通道，验证后也是走过的，返回到D，此时还有三条没有走过，一条条走，H,G,I,继续返回，直到回到顶点A，确认你已经完成了遍历任务。找到了9个顶点。</p>
<p><strong>深度优点遍历其实就是递归的过程，如果在仔细点，会发现转换成1-1的右图之后，就像是一棵树的前序遍历。从图中某个顶点V开始，访问此顶点，然后从V的未被访问的邻接点出发深度优先遍历图，直到图中所有和V有路径相通的顶点都被访问到。</strong> 事实上，我们这里说的是连通图。对于非连通图，只需要对它的连通分量分别进行深度优点遍历，即在先前一个顶点进行一次深度优先遍历后，如图中有顶点没有被访问，则选图中一个未曾被访问的顶点做起始点，重复上述过程，直到图中所有顶点都被访问到为止。</p>
<p><strong>深度优先遍历主要思想</strong>：以一个未被访问过的顶点作为起始顶点，沿当前顶点的边走到未访问过的顶点，往深处探索，直到没有未被访问过的顶点时，回到上个顶点，继续试探访问别的顶点，直到所有都被访问过。  </p>
<p>显然，深度优先遍历是沿图的某一个分支遍历到末端，然后回溯，再沿着另一条进行同样的遍历，直到所有顶点都被访问过为止。</p>
<p>则代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;     //深度优先遍历</span><br><span class="line">using namespace std;</span><br><span class="line">int book[100], sum, n, e[100][100];</span><br><span class="line">void dfs(int cur)</span><br><span class="line">&#123;</span><br><span class="line">	cout &lt;&lt; cur &lt;&lt; &quot; &quot;;</span><br><span class="line">	book[cur] = 1;</span><br><span class="line">	sum++;</span><br><span class="line">	if (sum == n)</span><br><span class="line">		return;</span><br><span class="line">	for (int i = 1; i &lt;= n; ++i)</span><br><span class="line">		if (e[cur][i] == 1 &amp;&amp; book[i] == 0)</span><br><span class="line">			dfs(i);</span><br><span class="line">	return;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	int m, a, b;</span><br><span class="line">	cin &gt;&gt; m &gt;&gt; n;</span><br><span class="line">	//初始化二维矩阵</span><br><span class="line">	for (int i = 1; i &lt;= m; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		for (int j = 1; j &lt;= n; ++j)</span><br><span class="line">		&#123;</span><br><span class="line">			if (i == j)</span><br><span class="line">				e[i][j] = 0;</span><br><span class="line">			else</span><br><span class="line">				e[i][j] = 99999999;   //假设99999999为正无穷</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	for (int i = 1; i &lt;= m; ++i)     //读入顶点间的边</span><br><span class="line">	&#123;</span><br><span class="line">		cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">		e[a][b] = 1;   </span><br><span class="line">		e[b][a] = 1;	//因为是无向图</span><br><span class="line">	&#125;</span><br><span class="line">	dfs(1);</span><br><span class="line">	system(&quot;pause&quot;);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>广度优先遍历</strong><br><strong>广度优先遍历（Breafth_First_Search）,又称广度优先搜索，简称BFS。</strong><br>如果说图的深度优先遍历类似于树的前序遍历，那么图的广度优先遍历就类似于树的层序遍历了。我们将图1-2的第一幅稍微变形，变形原则就是顶点A放置在最上第一层，让与他有边的顶点B,F成为第二层，再让B和F有边的顶点C,I,G,E为第三层，在将这四个顶点有边的D,H放在第四层，如图1-2第二幅图所示、此时在视觉上感觉图的形状发生了变化，其实顶点和边的关系还是完全相同的<br><img src="https://img-blog.csdnimg.cn/20200716121503675.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3hpYW5nanVueWVz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p><strong>广度优先遍历主要思想：</strong></p>
<p>首先以一个未被访问过的顶点作为起始顶点，访问其所有相邻的顶点，然后对每个相邻的顶点，再访问它们相邻的未被访问过的顶点，直到所有顶点都被访问过，遍历结束。</p>
<p>则代码如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;             //广度优先遍历</span><br><span class="line">#include&lt;queue&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int book[100], sum, n, e[100][100];</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	int m, a, b;</span><br><span class="line">	queue&lt;int&gt; q;</span><br><span class="line">	cin &gt;&gt; m &gt;&gt; n;</span><br><span class="line">	//初始化二维矩阵</span><br><span class="line">	for (int i = 1; i &lt;= m; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		for (int j = 1; j &lt;= n; ++j)</span><br><span class="line">		&#123;</span><br><span class="line">			if (i == j)</span><br><span class="line">				e[i][j] = 0;</span><br><span class="line">			else</span><br><span class="line">				e[i][j] = 99999999;   //假设99999999为正无穷</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	for (int i = 1; i &lt;= m; ++i)     //读入顶点间的边</span><br><span class="line">	&#123;</span><br><span class="line">		cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">		e[a][b] = 1;   </span><br><span class="line">		e[b][a] = 1;	//因为是无向图</span><br><span class="line">	&#125;</span><br><span class="line">	q.push(1);</span><br><span class="line">	book[1] = 1;</span><br><span class="line">	cout &lt;&lt; &quot;1&quot; &lt;&lt; &quot; &quot;;</span><br><span class="line">	while (!q.empty())</span><br><span class="line">	&#123;</span><br><span class="line">		for (int i = 1; i &lt;= n; ++i)</span><br><span class="line">		&#123;</span><br><span class="line">			if (e[q.front()][i] == 1 &amp;&amp; book[i] == 0)</span><br><span class="line">			&#123;</span><br><span class="line">				book[i] = 1;</span><br><span class="line">				q.push(i);</span><br><span class="line">				cout &lt;&lt; i &lt;&lt; &quot; &quot;;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		q.pop();</span><br><span class="line">	&#125;</span><br><span class="line">	system(&quot;pause&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/08/05/%E5%9B%BE%E7%9A%84%E9%81%8D%E5%8E%86/" data-id="cks347ape000280uw3ahv1c8n" data-title="图的遍历" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-万能搜索-1" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/08/05/%E4%B8%87%E8%83%BD%E6%90%9C%E7%B4%A2-1/" class="article-date">
  <time class="dt-published" datetime="2021-08-05T12:49:32.000Z" itemprop="datePublished">2021-08-05</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/08/05/%E4%B8%87%E8%83%BD%E6%90%9C%E7%B4%A2-1/">万能搜索</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>一、深度优先搜索（Depth First Search）<br>首先作者用上章遗留的全排列问题作为引例为我们介绍了DFS是啥东西。</p>
<p>题目1：输入一个数n 请输出1~n的全排列。</p>
<p>当然我们可以用上一章的枚举来做，并且用一个book[10]的数组还能减少一些麻烦，但其实还是很麻烦……而用dfs则简单得多。上代码。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int a[10], book[10], n;</span><br><span class="line">void dfs(int step)   //现在站在第step个盒子前。   </span><br><span class="line">&#123;	</span><br><span class="line">	if (step == n + 1)</span><br><span class="line">	&#123;</span><br><span class="line">		for (int i = 1; i &lt;= n; ++i)</span><br><span class="line">			cout &lt;&lt; a[i];</span><br><span class="line">		cout &lt;&lt; endl;</span><br><span class="line">		return;</span><br><span class="line">	&#125;</span><br><span class="line">	for (int i = 1; i &lt;= n; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		if (book[i]==0)    //牌在手上 </span><br><span class="line">		&#123;</span><br><span class="line">			a[step] = i;   //放入盒子中</span><br><span class="line">			book[i] = 1;     //牌不在手上了</span><br><span class="line">			dfs(step + 1);     //走向下一个盒子</span><br><span class="line">			book[i] = 0;     //把刚才尝试的牌都收回来，再进行下一次的排列尝试</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	return;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	cin &gt;&gt; n;</span><br><span class="line">	dfs(1);</span><br><span class="line">	system(&quot;pause&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其实主要要注意的是其中的递归问题。</p>
<p>分析：</p>
<p>首先我们站在第一个盒子（作者将每一个数比作一个对应的盒子）面前，所以main函数中是dfs(1)，在dfs函数中，我们将1到n每一个数都进行尝试，如果这个牌仍在手中，则放入盒子里，然后走向下一个盒子（dfs(step+1)），直到走到了n+1个盒子，当然这个盒子不存在，也就是说我们已经走到了尽头，便将排好的一个排列输出，return。作者说必须马上return，但其实并不需要，不会陷入死循环，因为在下方遍历1<del>n时并没有牌在手中，所以并不会继续dfs(step+1) 而是仍会执行最下面的return语句。（但是，最好还是写上那条return语句，因为可以不用再去遍历循环以提高效率，并且，if(step==n+1)这一语句块是递归的结束条件，一般来说在结束条件都要return以避免死循环的 所以养成好习惯不是坏事</del>）</p>
<p>当执行完一次排列后（也就是一次step到n+1后），return，则返回到上一次调用dfs的地方，也就是循环中的dfs(step+1)这一语句，其实这就是递归啦，那么下一句就是book[i]=0; 即收回刚才放入盒子中的牌，然后一直递归， 一直收牌，直到可以有不同排列时停止，此时便进行下一种排列。（这里最好自己脑子里想一遍全过程，下一段落我也给出了过程帮助理解）这也就是为什么作者说book[i]=0;这一语句十分重要的原因，如果不收回牌，则无法进行下一次排列。  最后，最后一条语句return也不要忘了。。</p>
<p>嗯，这里还是给一小部分过程帮助理解吧。比如要给出1到3的全排列。 最开始，我们是站在第一个盒子面前，从1<del>n遍历，因为有1，所以放进盒子中，手里也就没有1了，然后走向下一个盒子，从1</del>n遍历，没有1，但是有2，将2放入盒子中，手中没有2了……最后走到第四个盒子时，刚好放入了123，输出123，返回到上一次调用dfs函数的地方，即在第三个盒子处，我们将盒子三里的牌收回来（即3），因为在这时循环i==3 所以++i后循环结束，return 又到了上一个调用dfs函数的地方，则是在第二个盒子处，收回在第二个盒子里的牌（即2），此时循环i==2，++i，则i==3，因为我们有3，所以将3放在第二个盒子的位置，走向第三个盒子，从1~n遍历，因为有2，所以将2放入第三个盒子，然后走向第四个盒子，输出132。</p>
<p>之后的排列也是如此得到的，便不赘述了。</p>
<p>由这个全排列的例子，我们便可以了解到深度优先搜索的基本模型了。理解dfs的关键在于解决“当下该如何做”，至于下一步，则与当下是一样的。 比如全排列这道题，dfs函数就是解决面对第step个盒子时如何做，方法就是把每一种可能都尝试一遍，而step+1个盒子的解决办法是一样的，所以才使用递归。</p>
<p>基本模型：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">void dfs(int step)</span><br><span class="line">&#123;</span><br><span class="line">    判断边界</span><br><span class="line">    尝试每一种可能 for(int i=1;i&lt;=n;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        继续下一步 dfs(step+1);</span><br><span class="line">    &#125;</span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>题目2</strong>：解救小哈</p>
<p>迷宫由m行n列单元格组成(m,n均小于等于50)，每个单元格要么是空地要么是障碍物，你的任务是帮助小哼找到一条从迷宫起点通往小哈所在位置的最短路径。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int m, n, endx, endy, min = 99999999;   //地图为m行n列  (endx,endy)为目标坐标</span><br><span class="line">int a[55][55], book[55][55];    //a为地图二维数组（1为障碍物），book为现在所在坐标二维数组</span><br><span class="line">void dfs(int x, int y, int step)</span><br><span class="line">&#123;</span><br><span class="line">	int next[4][2] = &#123; &#123;0,1&#125;,&#123;1,0&#125;,&#123;0,-1&#125;,&#123;-1,0&#125; &#125;;   //右-&gt;下—&gt;左-&gt;上</span><br><span class="line">	int nx, ny;</span><br><span class="line">	if (x == endx &amp;&amp; y == endy)   //递归出口</span><br><span class="line">	&#123;</span><br><span class="line">		if (step &lt; min)</span><br><span class="line">			min = step;</span><br><span class="line">		return;</span><br><span class="line">	&#125;</span><br><span class="line">	for (int i = 0; i != 4; ++i)   //尝试四种走法</span><br><span class="line">	&#123;</span><br><span class="line">		nx = x + next[i][0];</span><br><span class="line">		ny = y + next[i][1];</span><br><span class="line">		if (nx&lt;1 || nx&gt;m || ny&lt;1 || ny&gt;n)</span><br><span class="line">			continue;</span><br><span class="line">		if (a[nx][ny] == 0 &amp;&amp; book[nx][ny] == 0)  //下一个点不是障碍物且没有走过</span><br><span class="line">		&#123;</span><br><span class="line">			book[nx][ny] = 1;</span><br><span class="line">			dfs(nx, ny, step + 1);</span><br><span class="line">			book[nx][ny] = 0;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	return;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	freopen(&quot;C:\\Users\\statue\\OneDrive\\桌面\\test.txt&quot;, &quot;r&quot;, stdin);</span><br><span class="line">	int startx, starty;</span><br><span class="line">	cin &gt;&gt; m &gt;&gt; n;</span><br><span class="line">	for (int i = 1; i&lt;= m; ++i)</span><br><span class="line">		for (int j = 1; j &lt;= n; ++j)</span><br><span class="line">			cin &gt;&gt; a[i][j];</span><br><span class="line">	cin &gt;&gt; startx &gt;&gt; starty &gt;&gt; endx &gt;&gt; endy;</span><br><span class="line">	book[startx][starty] = 1;  //避免重复走</span><br><span class="line">	dfs(startx, startx, 0);</span><br><span class="line">	cout &lt;&lt; min &lt;&lt; endl;</span><br><span class="line">	freopen(&quot;CON&quot;, &quot;r&quot;, stdin);</span><br><span class="line">	system(&quot;pause&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其实方法都是一样的，但我在自己敲的过程中有个bug找了很久。就是在最上方定义了全局变量m,n，但在main函数中我又习惯性的定义了m，n，这时局部变量m和n便覆盖了全局变量m和n 导致输出结果永远都是99999999。。</p>
<p>另外，作者定义的地图起点默认是（1，1） 当然我们也可以用（0，0）只需注意修改下循环和if条件的判断和起始坐标的输入即可。</p>
<p>解决解救小哈这一问题还可以用别的方法。这时也就引出了广度优先搜索。</p>
<p><strong>二、广度优先搜索（Breath First Search）</strong><br>广度优先搜索是用队列模拟实现的。我们最初站在原点，按右-&gt;下-&gt;左-&gt;上 一轮往周边搜索，若满足条件则让其入队，步数是在所站位置上的步数加一，搜索完后，将所站的点去掉，因为已经无用了，再往周边搜索，以此类推，直至找到目标。</p>
<p>这次我们便将原点设为（0，0）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int a[55][55], book[55][55];</span><br><span class="line">struct note</span><br><span class="line">&#123;</span><br><span class="line">	int x;</span><br><span class="line">	int y;</span><br><span class="line">	int step;</span><br><span class="line">&#125;que[2505];</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	int m, n, startx, starty, endx, endy, nx, ny, flag;</span><br><span class="line">	cin &gt;&gt; m &gt;&gt; n;                   //输入数据</span><br><span class="line">	for (int i = 0; i != m; ++i)</span><br><span class="line">		for (int j = 0; j != n; ++j)</span><br><span class="line">			cin &gt;&gt; a[i][j];</span><br><span class="line">	cin &gt;&gt; startx &gt;&gt; starty &gt;&gt; endx &gt;&gt; endy;</span><br><span class="line">	int head = 1, tail = 1;</span><br><span class="line">	que[tail].x = startx;          //在队列尾部添加初值</span><br><span class="line">	que[tail].y = starty;</span><br><span class="line">	que[tail].step = 0;</span><br><span class="line">	++tail;</span><br><span class="line">	flag = 0;       //判断是否找到的标记变量</span><br><span class="line">	book[startx][starty] = 1;</span><br><span class="line">	int next[4][2] = &#123; &#123;0,1&#125;,&#123;1,0&#125;,&#123;0,-1&#125;,&#123;-1,0&#125; &#125;;</span><br><span class="line">	while (head &lt; tail)</span><br><span class="line">	&#123;</span><br><span class="line">		for (int i = 0; i != 4; ++i)</span><br><span class="line">		&#123;</span><br><span class="line">			nx = que[head].x + next[i][0];</span><br><span class="line">			ny = que[head].y + next[i][1];</span><br><span class="line">			if (nx &lt; 0 || nx &gt;= m || ny &lt; 0 || ny &gt;= n)</span><br><span class="line">				continue;</span><br><span class="line">			if (a[nx][ny] == 0 &amp;&amp; book[nx][ny] == 0)</span><br><span class="line">			&#123;</span><br><span class="line">				book[nx][ny] = 1;</span><br><span class="line">				que[tail].x = nx;</span><br><span class="line">				que[tail].y = ny;</span><br><span class="line">				que[tail].step = que[head].step + 1;</span><br><span class="line">				++tail;</span><br><span class="line">			&#125;</span><br><span class="line">			if (nx == endx &amp;&amp; nx == endy)</span><br><span class="line">			&#123;</span><br><span class="line">				flag = 1;</span><br><span class="line">				break;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		if (flag == 1)</span><br><span class="line">			break;</span><br><span class="line">		++head;   //这样才能往前推进，进行下一次拓展</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; que[tail - 1].step &lt;&lt; endl;</span><br><span class="line">	system(&quot;pause&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>题目3</strong>：再解炸弹人</p>
<p>在第三章枚举中，炸弹人程序存在一些问题，就是求出的结果不是小哼能走过去的最佳点，而仅仅是数量最佳。要解决这一问题就需要搜索。(<strong>注意：题目已经修改了！第6行第11列的障碍物要改成空地！</strong>)</p>
<p><strong>法一（BFS）</strong>:、</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">struct  note</span><br><span class="line">&#123;</span><br><span class="line">	int x;</span><br><span class="line">	int y;</span><br><span class="line">&#125;;</span><br><span class="line">char a[25][25], book[25][25];</span><br><span class="line">int getnum(int i, int j)</span><br><span class="line">&#123;</span><br><span class="line">	int x, y, sum = 0;</span><br><span class="line">	x = i; y = j;</span><br><span class="line">	while (a[x][y] != &#x27;#&#x27;)    //向上统计</span><br><span class="line">	&#123;</span><br><span class="line">		if (a[x][y] == &#x27;G&#x27;)</span><br><span class="line">			sum++;</span><br><span class="line">		x--;</span><br><span class="line">	&#125;</span><br><span class="line">	x = i; y = j;</span><br><span class="line">	while (a[x][y] != &#x27;#&#x27;)    //向下统计</span><br><span class="line">	&#123;</span><br><span class="line">		if (a[x][y] == &#x27;G&#x27;)</span><br><span class="line">			sum++;</span><br><span class="line">		x++;</span><br><span class="line">	&#125;</span><br><span class="line">	x = i; y = j;</span><br><span class="line">	while (a[x][y] != &#x27;#&#x27;)    //向左统计</span><br><span class="line">	&#123;</span><br><span class="line">		if (a[x][y] == &#x27;G&#x27;)</span><br><span class="line">			sum++;</span><br><span class="line">		y--;</span><br><span class="line">	&#125;</span><br><span class="line">	x = i; y = j;</span><br><span class="line">	while (a[x][y] != &#x27;#&#x27;)    //向右统计</span><br><span class="line">	&#123;</span><br><span class="line">		if (a[x][y] == &#x27;G&#x27;)</span><br><span class="line">			sum++;</span><br><span class="line">		y++;</span><br><span class="line">	&#125;</span><br><span class="line">	return sum;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	struct note que[405];</span><br><span class="line">	int head = 1, tail = 1;</span><br><span class="line">	int m, n, sum, max=0, startx, starty, nx, ny, max_x, max_y;</span><br><span class="line">	int next[4][2] = &#123; &#123;0,1&#125;,&#123;1,0&#125;,&#123;0,-1&#125;,&#123;-1,0&#125; &#125;;</span><br><span class="line">	cin &gt;&gt; m &gt;&gt; n &gt;&gt; startx &gt;&gt; starty;</span><br><span class="line">	for (int i = 0; i != m; ++i)</span><br><span class="line">		for (int j = 0; j != n; ++j)</span><br><span class="line">			cin &gt;&gt; a[i][j];</span><br><span class="line">	que[tail].x = startx;</span><br><span class="line">	que[tail].y = starty;</span><br><span class="line">	++tail;</span><br><span class="line">	book[startx][starty] = 1;</span><br><span class="line">	max = getnum(startx, starty);</span><br><span class="line">	max_x = startx;</span><br><span class="line">	max_y = starty;</span><br><span class="line">	while (head &lt; tail)</span><br><span class="line">	&#123;</span><br><span class="line">		for (int i = 0; i != 4; ++i)</span><br><span class="line">		&#123;</span><br><span class="line">			nx = que[head].x + next[i][0];</span><br><span class="line">			ny = que[head].y + next[i][1];</span><br><span class="line">			if (nx&lt;0 || nx&gt;m - 1 || ny&lt;0 || ny&gt;n - 1)</span><br><span class="line">				continue;</span><br><span class="line">			if (a[nx][ny] == &#x27;.&#x27; &amp;&amp; book[nx][ny] == 0)</span><br><span class="line">			&#123;</span><br><span class="line">				book[nx][ny] = 1;</span><br><span class="line">				que[tail].x = nx;</span><br><span class="line">				que[tail].y = ny;</span><br><span class="line">				tail++;</span><br><span class="line">				sum = getnum(nx, ny);</span><br><span class="line">				if (sum &gt; max)</span><br><span class="line">				&#123;</span><br><span class="line">					max = sum;</span><br><span class="line">					max_x = nx;</span><br><span class="line">					max_y = ny;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		head++;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; &quot;将炸弹放在(&quot; &lt;&lt; max_x &lt;&lt; &quot;,&quot; &lt;&lt; max_y &lt;&lt; &quot;)可以消灭&quot; &lt;&lt; max &lt;&lt; &quot;个敌人&quot; &lt;&lt; endl;</span><br><span class="line">	system(&quot;pause&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>法二（DFS）</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">char a[25][25];</span><br><span class="line">int book[25][25], max, max_x, max_y, nx, ny, m, n;</span><br><span class="line">int getnum(int i, int j)</span><br><span class="line">&#123;</span><br><span class="line">	int x, y, sum = 0;</span><br><span class="line">	x = i; y = j;</span><br><span class="line">	while (a[x][y] != &#x27;#&#x27;)</span><br><span class="line">	&#123;</span><br><span class="line">		if (a[x][y] == &#x27;G&#x27;)</span><br><span class="line">			sum++;</span><br><span class="line">		x--;</span><br><span class="line">	&#125;</span><br><span class="line">	x = i; y = j;</span><br><span class="line">	while (a[x][y] != &#x27;#&#x27;)</span><br><span class="line">	&#123;</span><br><span class="line">		if (a[x][y] == &#x27;G&#x27;)</span><br><span class="line">			sum++;</span><br><span class="line">		x++;</span><br><span class="line">	&#125;</span><br><span class="line">	x = i; y = j;</span><br><span class="line">	while (a[x][y] != &#x27;#&#x27;)</span><br><span class="line">	&#123;</span><br><span class="line">		if (a[x][y] == &#x27;G&#x27;)</span><br><span class="line">			sum++;</span><br><span class="line">		y--;</span><br><span class="line">	&#125;</span><br><span class="line">	x = i; y = j;</span><br><span class="line">	while (a[x][y] != &#x27;#&#x27;)</span><br><span class="line">	&#123;</span><br><span class="line">		if (a[x][y] == &#x27;G&#x27;)</span><br><span class="line">			sum++;</span><br><span class="line">		y++;</span><br><span class="line">	&#125;</span><br><span class="line">	return sum;</span><br><span class="line">&#125;</span><br><span class="line">void dfs(int x, int y)</span><br><span class="line">&#123;</span><br><span class="line">	int next[4][2] = &#123; &#123;0,1&#125;,&#123;1,0&#125;,&#123;0,-1&#125;,&#123;-1,0&#125; &#125;;</span><br><span class="line">	int sum;</span><br><span class="line">	sum = getnum(x, y);</span><br><span class="line">	if (sum &gt; max)</span><br><span class="line">	&#123;</span><br><span class="line">		max = sum;</span><br><span class="line">		max_x = x;</span><br><span class="line">		max_y = y;</span><br><span class="line">	&#125;</span><br><span class="line">	for (int i = 0; i != 4; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		nx = x + next[i][0];</span><br><span class="line">		ny = y + next[i][1];</span><br><span class="line">		if (nx&lt;0 || nx&gt;m - 1 || ny&lt;0 || ny&gt;n - 1)</span><br><span class="line">			continue;</span><br><span class="line">		if (a[nx][ny] == &#x27;.&#x27;&amp;&amp;book[nx][ny] == 0)</span><br><span class="line">		&#123;</span><br><span class="line">			book[nx][ny] = 1;</span><br><span class="line">			dfs(nx,ny);</span><br><span class="line">			//book[nx][ny]=0;   不需要这步，因为只要遍历到就行，不管顺序</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	return;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	int startx, starty;</span><br><span class="line">	cin &gt;&gt; m &gt;&gt; n &gt;&gt; startx &gt;&gt; starty;</span><br><span class="line">	for (int i = 0; i != m; ++i)</span><br><span class="line">		for (int j = 0; j != n; ++j)</span><br><span class="line">			cin &gt;&gt; a[i][j];</span><br><span class="line">	dfs(startx, starty);</span><br><span class="line">	cout &lt;&lt; max_x &lt;&lt; &quot; &quot; &lt;&lt; max_y &lt;&lt; &quot; &quot; &lt;&lt; max &lt;&lt; endl;</span><br><span class="line">	system(&quot;pause&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>题目4</strong>：宝岛探险</p>
<p><strong>法一（BFS）： 利用了C++的queue （注意queue的struct构造：q.push({x,y})）</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;queue&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int a[15][15];</span><br><span class="line">int book[15][15];</span><br><span class="line">struct note</span><br><span class="line">&#123;</span><br><span class="line">	int x;</span><br><span class="line">	int y;</span><br><span class="line">	note() = default;</span><br><span class="line">	note(int i, int j) :x(i), y(j) &#123;&#125;;</span><br><span class="line">&#125;que[100];</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	int m, n, startx, starty, nx, ny, sum = 0;</span><br><span class="line">	queue&lt;note&gt; q;</span><br><span class="line">	int next[4][2] = &#123; &#123;0,1&#125;,&#123;1,0&#125;,&#123;0,-1&#125;,&#123;-1,0&#125; &#125;;</span><br><span class="line">	cin &gt;&gt; m &gt;&gt; n &gt;&gt; startx &gt;&gt; starty;</span><br><span class="line">	book[startx][starty] = 1;</span><br><span class="line">	for (int i = 1; i &lt;= m; ++i)</span><br><span class="line">		for (int j = 1; j &lt;= n; ++j)</span><br><span class="line">			cin &gt;&gt; a[i][j];</span><br><span class="line">	q.push(&#123; startx,starty &#125;);</span><br><span class="line">	sum++;</span><br><span class="line">	while (!q.empty())</span><br><span class="line">	&#123;</span><br><span class="line">		for (int i = 0; i != 4; ++i)</span><br><span class="line">		&#123;</span><br><span class="line">			nx = q.front().x + next[i][0];</span><br><span class="line">			ny = q.front().y + next[i][1];</span><br><span class="line">			if (nx&lt;1 || nx&gt;m || ny&lt;1 || ny&gt;n)</span><br><span class="line">				continue;</span><br><span class="line">			if (a[nx][ny] &gt; 0 &amp;&amp; book[nx][ny] == 0)</span><br><span class="line">			&#123;</span><br><span class="line">				book[nx][ny] = 1;</span><br><span class="line">				q.push(&#123; nx,ny &#125;);</span><br><span class="line">				sum++;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		q.pop();</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; sum &lt;&lt; endl：</span><br><span class="line">	system(&quot;pause&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>法二（DFS）</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int a[15][15], book[15][15];</span><br><span class="line">int m, n, sum = 0;</span><br><span class="line">void dfs(int x, int y)</span><br><span class="line">&#123;</span><br><span class="line">	int next[4][2] = &#123; &#123;0,1&#125;,&#123;1,0&#125;,&#123;0,-1&#125;,&#123;-1,0&#125; &#125;;</span><br><span class="line">	int nx, ny;</span><br><span class="line">	book[x][y] = 1;</span><br><span class="line">	sum++;</span><br><span class="line">	for (int i = 0; i != 4; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		nx = x + next[i][0];</span><br><span class="line">		ny = y + next[i][1];</span><br><span class="line">		if (nx&lt;1 || nx&gt;m || ny&lt;1 || ny&gt;n)</span><br><span class="line">			continue;</span><br><span class="line">		if (a[nx][ny] &gt; 0 &amp;&amp; book[nx][ny] == 0)</span><br><span class="line">			dfs(nx, ny);</span><br><span class="line">	&#125;</span><br><span class="line">	return;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	int startx, starty, nx, ny;</span><br><span class="line">	cin &gt;&gt; m &gt;&gt; n &gt;&gt; startx &gt;&gt; starty;</span><br><span class="line">	for (int i = 1; i &lt;= m; ++i)</span><br><span class="line">		for (int j = 1; j &lt;= n; ++j)</span><br><span class="line">			cin &gt;&gt; a[i][j];</span><br><span class="line">	dfs(startx, starty);</span><br><span class="line">	cout &lt;&lt; sum &lt;&lt; endl;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>


      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/08/05/%E4%B8%87%E8%83%BD%E6%90%9C%E7%B4%A2-1/" data-id="cks347ap6000080uwcps10oru" data-title="万能搜索" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-枚举" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/07/26/%E6%9E%9A%E4%B8%BE/" class="article-date">
  <time class="dt-published" datetime="2021-07-26T11:40:47.000Z" itemprop="datePublished">2021-07-26</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/07/26/%E6%9E%9A%E4%B8%BE/">枚举</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>C enum(枚举)**<br><strong>枚举是 C 语言中的一种基本数据类型，它可以让数据更简洁，更易读</strong>。</p>
<p>枚举语法定义格式为：</p>
<p><strong>enum　枚举名　{枚举元素1,枚举元素2,……};</strong><br>接下来我们举个例子，比如：一星期有 7 天，如果不用枚举，我们需要使用 #define 来为每个整数定义一个别名：</p>
<p>#define MON 1<br>#define TUE 2<br>#define WED 3<br>#define THU 4<br>#define FRI 5<br>#define SAT 6<br>#define SUN 7<br>这个看起来代码量就比较多，接下来我们看看使用枚举的方式：</p>
<p>enum DAY<br>{<br>MON=1, TUE, WED, THU, FRI, SAT, SUN<br>};<br>这样看起来是不是更简洁了。</p>
<p>注意：第一个枚举成员的默认值为整型的 0，后续枚举成员的值在前一个成员上加 1。我们在这个实例中把第一个枚举成员的值定义为 1，第二个就为 2，以此类推。</p>
<p>可以在定义枚举类型时改变枚举元素的值：</p>
<p>enum season {spring, summer=3, autumn, winter};<br>没有指定值的枚举元素，其值为前一元素加 1。也就说 spring 的值为 0，summer 的值为 3，autumn 的值为 4，winter 的值为 5</p>
<p><strong>枚举变量的定义</strong><br>前面我们只是声明了枚举类型，接下来我们看看如何定义枚举变量。</p>
<p>我们可以通过以下三种方式来定义枚举变量</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">1、先定义枚举类型，再定义枚举变量</span><br><span class="line"></span><br><span class="line">enum DAY</span><br><span class="line">&#123;</span><br><span class="line">MON=1, TUE, WED, THU, FRI, SAT, SUN</span><br><span class="line">&#125;;</span><br><span class="line">enum DAY day;</span><br><span class="line">2、定义枚举类型的同时定义枚举变量</span><br><span class="line"></span><br><span class="line">enum DAY</span><br><span class="line">&#123;</span><br><span class="line">MON=1, TUE, WED, THU, FRI, SAT, SUN</span><br><span class="line">&#125; day;</span><br><span class="line">3、省略枚举名称，直接定义枚举变量</span><br><span class="line"></span><br><span class="line">enum</span><br><span class="line">&#123;</span><br><span class="line">MON=1, TUE, WED, THU, FRI, SAT, SUN</span><br><span class="line">&#125; day;</span><br><span class="line">实例</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">enum DAY</span><br><span class="line">&#123;</span><br><span class="line">MON=1, TUE, WED, THU, FRI, SAT, SUN</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">enum DAY day;</span><br><span class="line">day = WED;</span><br><span class="line">printf(&quot;%d&quot;,day);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3<br>在C 语言中，枚举类型是被当做 int 或者 unsigned int 类型来处理的，所以按照 C 语言规范是没有办法遍历枚举类型的。</p>
<p>不过在一些特殊的情况下，<strong>枚举类型必须连续是可以实现有条件的遍历。</strong></p>
<p><strong>以下实例使用 for 来遍历枚举的元素</strong>：</p>
<p>实例</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">enum DAY</span><br><span class="line">&#123;</span><br><span class="line">MON=1, TUE, WED, THU, FRI, SAT, SUN</span><br><span class="line">&#125; day;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">// 遍历枚举元素</span><br><span class="line">for (day = MON; day &lt;= SUN; day++) &#123;</span><br><span class="line">printf(“枚举元素：%d \n”, day);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">以上实例输出结果为：</span><br><span class="line"></span><br><span class="line">枚举元素：1</span><br><span class="line">枚举元素：2</span><br><span class="line">枚举元素：3</span><br><span class="line">枚举元素：4</span><br><span class="line">枚举元素：5</span><br><span class="line">枚举元素：6</span><br><span class="line">枚举元素：7</span><br><span class="line">以下枚举类型不连续，这种枚举无法遍历。</span><br><span class="line"></span><br><span class="line">enum</span><br><span class="line">&#123;</span><br><span class="line">ENUM_0,</span><br><span class="line">ENUM_10 = 10,</span><br><span class="line">ENUM_11</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>枚举在 switch 中的使用：</strong></p>
<p><strong>实例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">enum color &#123; red=1, green, blue &#125;;</span><br><span class="line"></span><br><span class="line">enum  color favorite_color;</span><br><span class="line"></span><br><span class="line">/* 用户输入数字来选择颜色 */</span><br><span class="line">printf(&quot;请输入你喜欢的颜色: (1. red, 2. green, 3. blue): &quot;);</span><br><span class="line">scanf(&quot;%u&quot;, &amp;favorite_color);</span><br><span class="line"></span><br><span class="line">/* 输出结果 */</span><br><span class="line">switch (favorite_color)</span><br><span class="line">&#123;</span><br><span class="line">case red:</span><br><span class="line">    printf(&quot;你喜欢的颜色是红色&quot;);</span><br><span class="line">    break;</span><br><span class="line">case green:</span><br><span class="line">    printf(&quot;你喜欢的颜色是绿色&quot;);</span><br><span class="line">    break;</span><br><span class="line">case blue:</span><br><span class="line">    printf(&quot;你喜欢的颜色是蓝色&quot;);</span><br><span class="line">    break;</span><br><span class="line">default:</span><br><span class="line">    printf(&quot;你没有选择你喜欢的颜色&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/07/26/%E6%9E%9A%E4%B8%BE/" data-id="cks347apf000380uw677l0eeb" data-title="枚举" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-栈的基本概念" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/07/11/%E6%A0%88%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/" class="article-date">
  <time class="dt-published" datetime="2021-07-11T12:13:52.166Z" itemprop="datePublished">2021-07-11</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/07/11/%E6%A0%88%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/">栈的基本概念</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="一、栈的基本概念"><a href="#一、栈的基本概念" class="headerlink" title="一、栈的基本概念"></a>一、栈的基本概念</h2><h3 id="1、栈的定义"><a href="#1、栈的定义" class="headerlink" title="1、栈的定义"></a>1、栈的定义</h3><p><strong>栈</strong>（Stack）：是只允许在一端进行插入或删除的线性表。首先栈是一种<a target="_blank" rel="noopener" href="https://blog.csdn.net/Real_Fool_/article/details/113463997">线性表</a>，但限定这种线性表只能在某一端进行插入和删除操作。</p>
<p>二、栈的顺序存储结构<br>1、栈的顺序存储<br>采用顺序存储的栈称为顺序栈，它利用一组地址连续的存储单元存放自栈底到栈顶的数据元素，同时附设一个指针（top）指示当前栈顶元素的位置。<br>若存储栈的长度为StackSize，则栈顶位置top必须小于StackSize。当栈存在一个元素时，top等于0，因此通常把空栈的判断条件定位top等于-1。<br>栈的顺序存储结构可描述为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#define MAXSIZE 50;  //定义栈中元素的最大个数</span><br><span class="line">typedef int ElemType;   //ElemType的类型根据实际情况而定，这里假定为int</span><br><span class="line">typedef struct&#123;</span><br><span class="line">    ElemType data[MAXSIZE];</span><br><span class="line">    int top;    //用于栈顶指针</span><br><span class="line">&#125;SqStack;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="（3）进栈"><a href="#（3）进栈" class="headerlink" title="（3）进栈"></a>（3）进栈</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">/*插入元素e为新的栈顶元素*/</span><br><span class="line">Status Push(SqStack *S, ElemType e)&#123;</span><br><span class="line">    //满栈</span><br><span class="line">    if(S-&gt;top == MAXSIZE-1)&#123;</span><br><span class="line">        return ERROR;</span><br><span class="line">    &#125;</span><br><span class="line">    S-&gt;top++;   //栈顶指针增加一</span><br><span class="line">    S-&gt;data[S-&gt;top] = e;    //将新插入元素赋值给栈顶空间</span><br><span class="line">    return OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="（4）出栈"><a href="#（4）出栈" class="headerlink" title="（4）出栈"></a>（4）出栈</h4><p>出栈操作pop，代码如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">/*若栈不空，则删除S的栈顶元素，用e返回其值，并返回OK；否则返回ERROR*/</span><br><span class="line">Status Pop(SqStack *S, ElemType *e)&#123;</span><br><span class="line">    if(S-&gt;top == -1)&#123;</span><br><span class="line">        return ERROR;</span><br><span class="line">    &#125;</span><br><span class="line">    *e = S-&gt;data[S-&gt;top];   //将要删除的栈顶元素赋值给e</span><br><span class="line">    S-&gt;top--;   //栈顶指针减一</span><br><span class="line">    return OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="二、队列的顺序存储结构"><a href="#二、队列的顺序存储结构" class="headerlink" title="二、队列的顺序存储结构"></a>二、队列的顺序存储结构</h2><p>队列的顺序实现是指分配一块连续的存储单元存放队列中的元素，并附设两个指针：队头指针 front指向队头元素，队尾指针 rear 指向队尾元素的下一个位置。</p>
<h3 id="1、顺序队列"><a href="#1、顺序队列" class="headerlink" title="1、顺序队列"></a>1、顺序队列</h3><p>队列的顺序存储类型可描述为:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#define MAXSIZE 50;	//定义队列中元素的最大个数</span><br><span class="line">typedef struct&#123;</span><br><span class="line">	ElemType data[MAXSIZE];	//存放队列元素</span><br><span class="line">	int front,rear;</span><br><span class="line">&#125;SqQueue;</span><br></pre></td></tr></table></figure>

<p>2、循环队列<br>解决假溢出的方法就是后面满了，就再从头开始，也就是头尾相接的循环。我们把队列的这种头尾相接的顺序存储结构称为循环队列。<br>当队首指针Q-&gt;front = MAXSIZE-1后，再前进一个位置就自动到0，这可以利用除法取余运算（%）来实现。</p>
<p>初始时：Q-&gt;front = Q-&gt;rear=0。<br>队首指针进1：Q-&gt;front = (Q-&gt;front + 1) % MAXSIZE。<br>队尾指针进1：Q-&gt;rear = (Q-&gt;rear + 1) % MAXSIZE。<br>队列长度：(Q-&gt;rear - Q-&gt;front + MAXSIZE) % MAXSIZE。</p>
<h3 id="3、循环队列常见基本算法"><a href="#3、循环队列常见基本算法" class="headerlink" title="3、循环队列常见基本算法"></a>3、循环队列常见基本算法</h3><h4 id="（1）循环队列的顺序存储结构"><a href="#（1）循环队列的顺序存储结构" class="headerlink" title="（1）循环队列的顺序存储结构"></a>（1）循环队列的顺序存储结构</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">typedef int ElemType;   //ElemType的类型根据实际情况而定，这里假定为int</span><br><span class="line">#define MAXSIZE 50;  //定义元素的最大个数</span><br><span class="line">/*循环队列的顺序存储结构*/</span><br><span class="line">typedef struct&#123;</span><br><span class="line">    ElemType data[MAXSIZE];</span><br><span class="line">    int front;  //头指针</span><br><span class="line">    int rear;   //尾指针,若队列不空，指向队列尾元素的下一个位置</span><br><span class="line">&#125;SqQueue;</span><br></pre></td></tr></table></figure>

<h4 id="（2）循环队列的初始化"><a href="#（2）循环队列的初始化" class="headerlink" title="（2）循环队列的初始化"></a>（2）循环队列的初始化</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/*初始化一个空队列Q*/</span><br><span class="line">Status InitQueue(SqQueue *Q)&#123;</span><br><span class="line">    Q-&gt;front = 0;</span><br><span class="line">    Q-&gt;rear = 0;</span><br><span class="line">    return OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="（5）循环队列入队"><a href="#（5）循环队列入队" class="headerlink" title="（5）循环队列入队"></a>（5）循环队列入队</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">/*若队列未满，则插入元素e为Q新的队尾元素*/</span><br><span class="line">Status EnQueue(SqQueue *Q, ElemType e)&#123;</span><br><span class="line">    if((Q-&gt;real + 1) % MAXSIZE == Q-&gt;front)&#123;</span><br><span class="line">        return ERROR;   //队满</span><br><span class="line">    &#125;</span><br><span class="line">    Q-&gt;data[Q-&gt;rear] = e;   //将元素e赋值给队尾</span><br><span class="line">    Q-&gt;rear = (Q-&gt;rear + 1) % MAXSIZE;  //rear指针向后移一位置，若到最后则转到数组头部</span><br><span class="line">    return OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="（6）循环队列出队"><a href="#（6）循环队列出队" class="headerlink" title="（6）循环队列出队"></a>（6）循环队列出队</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">/*若队列不空，则删除Q中队头元素，用e返回其值*/</span><br><span class="line">Status DeQueue(SqQueue *Q, ElemType *e)&#123;</span><br><span class="line">    if(isEmpty(Q))&#123;</span><br><span class="line">        return REEOR;   //队列空的判断</span><br><span class="line">    &#125;</span><br><span class="line">    *e = Q-&gt;data[Q-&gt;front]; //将队头元素赋值给e</span><br><span class="line">    Q-&gt;front = (Q-&gt;front + 1) % MAXSIZE;    //front指针向后移一位置，若到最后则转到数组头部</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/07/11/%E6%A0%88%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/" data-id="cks347aph000580uw4g0b1v9m" data-title="栈的基本概念" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-hello-world" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/06/18/hello-world/" class="article-date">
  <time class="dt-published" datetime="2021-06-18T05:38:19.549Z" itemprop="datePublished">2021-06-18</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/06/18/hello-world/">Hello World</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>Welcome to <a target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a target="_blank" rel="noopener" href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a target="_blank" rel="noopener" href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a target="_blank" rel="noopener" href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/06/18/hello-world/" data-id="cks347apb000180uwg6egffk7" data-title="Hello World" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  


</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/08/">August 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/07/">July 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/06/">June 2021</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2021/08/08/%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E2%80%9C/">最短路径“</a>
          </li>
        
          <li>
            <a href="/2021/08/05/%E5%9B%BE%E7%9A%84%E9%81%8D%E5%8E%86/">图的遍历</a>
          </li>
        
          <li>
            <a href="/2021/08/05/%E4%B8%87%E8%83%BD%E6%90%9C%E7%B4%A2-1/">万能搜索</a>
          </li>
        
          <li>
            <a href="/2021/07/26/%E6%9E%9A%E4%B8%BE/">枚举</a>
          </li>
        
          <li>
            <a href="/2021/07/11/%E6%A0%88%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/">栈的基本概念</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2021 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>